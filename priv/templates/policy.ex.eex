defmodule <%= module %> do
  @moduledoc """
  Authorization for <%= app_namespace %> resources.
  """
  use Janus
  alias <%= app_namespace %>.Repo

  @impl true
  def policy_for(policy, _user) do
    # Attach permissions here using the `Janus.Policy` API
    policy
  end

  @doc """
  Load and authorize a resource.

  Returns `{:ok, resource}` if the actor is authorized, otherwise
  `{:error, :not_authorized}`.

  ## Examples

      iex> load_and_authorize(MyResource, :read, user, id: resource_id)
      {:ok, %MyResource{...}}

      iex> load_and_authorize(Restricted, :read, user, id: resource_id)
      {:error, :not_authorized}

      iex> load_and_authorize(MyResource, :read, user, other_unique_key: key)
      {:ok, %MyResource{...}}
  """
  def load_and_authorize(schema, action, actor, clauses)
      when is_atom(schema) and is_list(clauses) do
    schema
    |> Repo.get_by(clauses)
    |> authorize(action, actor)
  end

  @doc """
  Loads authorized resources.

  Returns `{:ok, resources}` if the actor has access to any resources from `schema`,
  otherwise `{:error, :not_authorized}`.

  Note that `{:ok, []}` only means that the query returned no results, not that the actor
  was unauthorized.

  ## Examples

      iex> load_authorized(MyResource, :read, user)
      {:ok, [%MyResource{...}, ...]}

      iex> load_authorized(Restricted, :read, user)
      {:error, :not_authorized}

      iex> MyResource
      ...> order_by(desc: :inserted_at)
      ...> load_authorized(MyResource, :read, user)
      {:ok, [%MyResource{...}, ...]}
  """
  def load_authorized(query_or_schema, action, actor, opts \\ []) do
    policy = policy_for(actor)

    if any_authorized?(query_or_schema, action, policy) do
      {:ok, scope(query_or_schema, action, policy, opts) |> Repo.all()}
    else
      {:error, :not_authorized}
    end
  end

  @doc """
  Validates that the resource being changed is authorized both before and after applying
  changes.

  ## Options

    * `:error_key` - the key to which the error will be added if authorization fails,
      defaults to `:current_user`
    * `:pre_message` - the message in case the authorization check fails on the resource
      prior to applying changes, defaults to "is not authorized to change this resource"
    * `:post_message` - the message in case the authorization check fails on the resource
      after applying changes, defaults to "is not authorized to make these changes"

  ## Examples

      iex> %MyResource{}
      ...> |> MyResource.changeset(attrs)
      ...> |> MyPolicy.validate_authorized(:update, current_user)
      %Ecto.Changeset{}
  """
  def validate_authorized(%Ecto.Changeset{} = changeset, action, actor_or_policy, opts \\ []) do
    policy = policy_for(actor_or_policy)

    opts =
      Keyword.validate!(opts,
        error_key: :current_user,
        pre_message: "is not authorized to change this resource",
        post_message: "is not authorized to make these changes"
      )

    with {:pre, {:ok, data}} <- {:pre, authorize(changeset.data, action, policy)},
         new_data <- Ecto.Changeset.apply_changes(changeset),
         {:post, {:ok, _data}} <- {:post, authorize(new_data, action, policy)} do
      %{changeset | data: data}
    else
      {:pre, {:error, :not_authorized}} ->
        Ecto.Changeset.add_error(changeset, opts[:error_key], opts[:pre_message], policy: policy)

      {:post, {:error, :not_authorized}} ->
        Ecto.Changeset.add_error(changeset, opts[:error_key], opts[:post_message], policy: policy)
    end
  end
end
