# Cheatsheet

## Installation and setup
{: .col-2}

### Dependency

#### mix.exs

```elixir
defp deps do
  [
    {:ex_janus, github: "zachallaun/ex_janus"}
  ]
end
```

Ecto v3.9.4 or later and a database that supports lateral joins (like PostgreSQL) is required to use all Janus features.

### Policy module

#### lib/my_app/policy.ex

```elixir
defmodule MyApp.Policy do
  use Janus

  @impl true
  def policy_for(policy, user) do
    policy
    |> # authorization rules
  end
end
```

Your policy module is the interface used by the rest of your application.
This is usually the only place you should be referring to `Janus` directly.

### Formatter (optional)

#### .formatter.exs

```elixir
[
  import_deps: [:janus]
]
```

This may be desired if you're using hooks. See `Janus.Policy.before_policy_for/1` for more.

## Reference schemas
{: .col-2}

### Users

```elixir
defmodule User do
  use Ecto.Schema

  schema "users" do
    field :email, :string
    field :display_name, :string

    field :role, Ecto.Enum,
      values: [:member, :moderator, :admin]

    has_many :posts, Post
    has_many :comments, Comment
  end
end
```

### Posts

```elixir
defmodule Post do
  use Ecto.Schema

  schema "posts" do
    field :title, :string
    field :content, :string

    field :archived, :boolean,
      default: false

    belongs_to :user, User
    has_many :comments, Comment
  end
end
```

### Comments

```elixir
defmodule Comment do
  use Ecto.Schema

  schema "comments" do
    field :content, :string

    belongs_to :user, User
    belongs_to :post, Post
  end
end
```

## Core concepts
{: .col-2}

### Schemas

Schemas are modules that invoke `use Ecto.Schema` and are used to identify different resources in your application.

#### When defining policies

```elixir
policy
|> allow(:edit, Post, ...)
#               ^^^^
```

#### When generating a query

```elixir
MyApp.Policy.filter_authorized(Post, :edit, current_user)
#                        ^^^^
```

#### When checking whether any auth rules are defined

```elixir
MyApp.Policy.any_authorized?(Post, :edit, current_user)
#                      ^^^^
```

### Resources

Resources are loaded structs defined by one of your schemas.

#### When authorizing an action

```elixir
MyApp.Policy.authorize(%Post{}, :edit, current_user)
#                ^^^^^^^
```

### Actors

Actors are the users of your application.
They can be a `%User{}` struct, but they don't have to be.
Actors are converted to a policy using `policy_for/2`, so an actor can be anything that you want to use to differentiate between types of user.
They can even be a simple atom like `:normal_user` or `:admin_user`.

#### In `policy_for/2`

```elixir
def policy_for(policy, %User{}) do
  #                    ^^^^^^^
end
```

#### When calling any authorization function

```elixir
MyApp.Policy.authorize(%Post{}, :edit, current_user)
#                                ^^^^^^^^^^^^
```

### Actions

Actions are what actors _do to_ resources in your application.
Janus doesn't care how you represent actions, but atoms usually do the trick.

#### When defining policies

```elixir
policy
|> allow(:edit, Post, ...)
#        ^^^^^
```

#### When calling any authorization function

```elixir
MyApp.Policy.authorize(%Post{}, :edit, current_user)
#                         ^^^^^
```

#### Can be any term (except a list)

```elixir
policy
|> allow(:edit, Post, ...)
|> allow("edit", Post, ...)
|> allow(%Action{type: :edit}, Post, ...)
# lists are special-cased to allow multiple actions to share conditions
|> allow([:read, :edit], Post, ...)
```

## Permitting actions
{: .col-2}

### Grant permission for all resources of schema

```elixir
policy
|> allow(:read, Post)
|> allow(:edit, Post)
|> allow(:archive, Post)
|> allow(:read, Comment)
|> allow(:edit, Comment)
```

### Using lists of actions

```elixir
policy
|> allow([:read, :edit, :archive], Post)
|> allow([:read, :edit], Comment)
```

### Grant permission based on resource attributes

```elixir
policy
|> allow(:read, Post, where: [archived: false])

# or define using :where_not
|> allow(:read, Post, where_not: [archived: true])

# or override a blanket permission using forbid
|> allow(:read, Post)
|> forbid(:read, Post, where: [archived: true])
```

### Grant permission if the user is associated with the resource

```elixir
def policy_for(policy, %User{role: :member} = user) do
  policy
  |> allow(:edit, Comment, where: [user_id: user.id])
end
```

### Grant permission based on association attributes

```elixir
policy
|> allow(:edit, Comment, where: [user: [role: :member]])
```

### Use `allows` to delegate permission to an association

```elixir
policy
|> allow(:read, Post, where: [archived: false])
|> allow(:read, Comment, where: [post: allows(:read)])
```

### Multiple `allow` combines as a logical-or

```elixir
# This will always allow reading all posts
policy
|> allow(:read, Post)
|> allow(:read, Post, where: [archived: false]) # has no effect
```

### Use `forbid` to override a previous `allow`

```elixir
policy
|> allow(:read, Post)
|> forbid(:read, Post, where: [archived: true])
```

## Structuring your policy definition
{: .col-2}

### Pattern-match to give different permissions to different actors

```elixir
def policy_for(policy, %User{role: :member}) do
  # member permissions
end

def policy_for(policy, %User{role: :moderator}) do
  # moderator permissions
end
```

### Delegate to context-specific policies

```elixir
def policy_for(policy, actor) do
  policy
  |> CommunityForum.Policy.policy_for(actor)
  |> Storefront.Policy.policy_for(actor)
end
```

For larger applications with well-defined boundaries, a policy can be constructed by threading it through multiple `policy_for` calls.

## Authorization
{: .col-2}

### Using policies in a context module

Policies should most often be used in context modules, since they provide the interface to actions and resources that the rest of your application uses.

```elixir
defmodule MyApp.MessageBoard do
  @moduledoc """
  Context module for the message board.
  """
  import Ecto.Query

  # imports authorize, any_authorized?, filter_authorized, etc.
  import MyApp.Policy

  alias MyApp.Repo

  # ...
end
```

### Authorizing an action on a resource

```elixir
def update_post(%Post{} = post, attrs \\ %{}, user_or_policy) do
  case authorize(post, :edit, user_or_policy) do
    {:ok, post} ->
      post
      |> Post.changeset(attrs)
      |> Repo.insert()

    :error ->
      {:error, :not_authorized}
  end
end
```

### Fetching authorized resources

```elixir
def authorized_posts(user_or_policy) do
  if any_authorized?(Post, :read, user_or_policy) do
    posts =
      Post
      |> filter_authorized(:read, user_or_policy)
      |> Repo.all()

    {:ok, posts}
  else
    {:error, :not_authorized}
  end
end
```

Use `any_authorized?/3` to differentiate between a result that is empty because there are no resources that match the policy conditions and a result that is empty because the user isn't authorized to view _any_ resources.

### Preloading authorized associations

```elixir
filter_authorized(Post, :read, user_or_policy,
  preload_authorized: :comments
)
```

```elixir
filter_authorized(Post, :read, user_or_policy,
  preload_authorized: [comments: :user]
)
```

The `:preload_authorized` option can be passed to preload only those associated resources that are authorized for the given action.

### Applying a query to preloads

```elixir
latest_comment_query =
  from Comment,
    order_by: [desc: :inserted_at],
    limit: 1

filter_authorized(Post, :read, user_or_policy,
  preload_authorized: [comments: latest_comment_query]
)
```

A query can be applied to associated authorized resources.
It is scoped per-association, so it applies to comments of _each_ post instead of the comments of _all_ posts.
The above would return all `:read`-able posts preloaded with their latest `:read`-able comment.

You can still include nested preloads using a tuple:

```elixir
filter_authorized(Post, :read, user_or_policy,
  preload_authorized: [comments: {latest_comment_query, [:user]}]
)
```

## Caching a policy
{: .col-2}

### Call `policy_for/1` to get the policy for a user

```elixir
iex> policy = MyApp.Policy.policy_for(current_user)
%Janus.Policy{...}
```

### Pass a policy anywhere you'd pass in an actor

```elixir
iex> MyApp.Policy.authorize(post, :read, policy)
{:ok, post}

iex> MyApp.Policy.filter_authorized(Post, :read, policy)
%Ecto.Query{}
```

### Cache a policy in a `Plug.Conn`

```elixir
def assign_current_policy(conn) do
  %{assigns: %{current_user: user}} = conn

  conn
  |> assign(:current_policy, MyApp.Policy.policy_for(user))
end
```

```elixir
def index(conn, _params) do
  %{assigns: %{current_policy: policy}} = conn

  # Pass the policy to your context
  case MessageBoard.authorized_posts(policy) do
    {:ok, posts} ->
      ...

    {:error, :not_authorized} ->
      ...
  end
end
```
